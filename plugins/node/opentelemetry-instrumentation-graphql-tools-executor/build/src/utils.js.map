{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../src/utils.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;GAcG;;;AAGH,0CAA0C;AAC1C,iCAAoC;AACpC,2DAAwD;AACxD,uCAA0E;AAU1E,gFAOgE;AAN9D,kGAAA,SAAS,OAAA;AACT,mHAAA,0BAA0B,OAAA;AAC1B,sGAAA,aAAa,OAAA;AACb,gGAAA,OAAO,OAAA;AACP,qGAAA,YAAY,OAAA;AACZ,mGAAA,UAAU,OAAA;AAGZ,kFAGgE;AAGhE,8EAA8E;AAC9E,MAAM,YAAY,GAAG,CAAC,KAAc,EAAuC,EAAE;IAC3E,OAAO,OAAO,KAAK,IAAI,QAAQ,IAAI,KAAK,KAAK,IAAI,CAAC;AACpD,CAAC,CAAC;AAEF,SAAS,sBAAsB,CAC7B,MAAkB,EAClB,SAAmD,EACnD,YAAiB,EACjB,IAAqC,EACrC,IAAc;IAKd,IAAI,KAAK,GAAG,QAAQ,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;IAEzC,IAAI,SAAS,GAAG,KAAK,CAAC;IAEtB,IAAI,CAAC,KAAK,EAAE;QACV,SAAS,GAAG,IAAI,CAAC;QACjB,MAAM,MAAM,GAAG,cAAc,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;QAElD,KAAK,GAAG;YACN,MAAM;YACN,IAAI,EAAE,kBAAkB,CACtB,MAAM,EACN,SAAS,EACT,YAAY,EACZ,IAAI,EACJ,IAAI,EACJ,MAAM,CAAC,IAAI,CACZ;YACD,KAAK,EAAE,IAAI;SACZ,CAAC;QAEF,QAAQ,CAAC,YAAY,EAAE,IAAI,EAAE,KAAK,CAAC,CAAC;KACrC;IAED,OAAO,EAAE,SAAS,EAAE,KAAK,EAAE,CAAC;AAC9B,CAAC;AAED,SAAS,kBAAkB,CACzB,MAAkB,EAClB,SAAmD,EACnD,YAAiB,EACjB,IAAqC,EACrC,IAAc,EACd,UAAqB;;IAErB,MAAM,UAAU,GAAuB;QACrC,CAAC,+BAAc,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,SAAS;QAC3C,CAAC,+BAAc,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC;QAC3C,CAAC,+BAAc,CAAC,UAAU,CAAC,EAAE,IAAI,CAAC,UAAU,CAAC,QAAQ,EAAE;KACxD,CAAC;IAEF,MAAM,IAAI,GAAG,MAAM,CAAC,SAAS,CAC3B,gBAAS,CAAC,OAAO,EACjB;QACE,UAAU;KACX,EACD,UAAU,CAAC,CAAC,CAAC,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAC7E,CAAC;IAEF,MAAM,QAAQ,GAAG,YAAY,CAAC,kCAAwB,CAAC,CAAC,MAAM,CAAC;IAC/D,MAAM,SAAS,GAAG,IAAI,CAAC,UAAU,CAAC,IAAI,CACpC,SAAS,CAAC,EAAE,CAAC,SAAS,CAAC,IAAI,KAAK,OAAO,CACxC,CAAC;IAEF,IAAI,SAAS,EAAE;QACb,IAAA,qBAAa,EACX,IAAI,EACJ,QAAQ,CAAC,GAAG,EACZ,SAAS,EAAE,CAAC,WAAW,EACvB,MAAA,SAAS,CAAC,GAAG,0CAAE,KAAK,EACpB,MAAA,SAAS,CAAC,GAAG,0CAAE,GAAG,CACnB,CAAC;KACH;IAED,OAAO,IAAI,CAAC;AACd,CAAC;AAGD,SAAS,QAAQ,CAAC,YAAiB,EAAE,IAAc,EAAE,KAAmB;IACtE,OAAO,CAAC,YAAY,CAAC,kCAAwB,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC;QACnE,KAAK,CAAC,CAAC;AACX,CAAC;AAED,SAAS,QAAQ,CAAC,YAAiB,EAAE,IAAc;IACjD,OAAO,YAAY,CAAC,kCAAwB,CAAC,CAAC,MAAM,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC;AACvE,CAAC;AAED,SAAS,cAAc,CAAC,YAAiB,EAAE,IAAc;IACvD,KAAK,IAAI,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;QACxC,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAY,EAAE,IAAI,CAAC,KAAK,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,CAAC;QAEvD,IAAI,KAAK,EAAE;YACT,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO;QACL,IAAI,EAAE,YAAY,CAAC,kCAAwB,CAAC,CAAC,IAAI;KAClD,CAAC;AACJ,CAAC;AAED,SAAS,WAAW,CAAC,UAAmB,EAAE,IAAiB;IACzD,MAAM,SAAS,GAAa,EAAE,CAAC;IAC/B,IAAI,IAAI,GAA4B,IAAI,CAAC;IACzC,OAAO,IAAI,EAAE;QACX,IAAI,GAAG,GAAG,IAAI,CAAC,GAAG,CAAC;QAEnB,IAAI,UAAU,IAAI,OAAO,GAAG,KAAK,QAAQ,EAAE;YACzC,GAAG,GAAG,GAAG,CAAC;SACX;QACD,SAAS,CAAC,IAAI,CAAC,MAAM,CAAC,GAAG,CAAC,CAAC,CAAC;QAC5B,IAAI,GAAG,IAAI,CAAC,IAAI,CAAC;KAClB;IACD,OAAO,SAAS,CAAC,OAAO,EAAE,CAAC;AAC7B,CAAC;AAOD,MAAM,sBAAsB,GAAG,CAC7B,WAAqB,EACrB,GAAQ,EACR,aAAsB,EACtB,EAAE;IACF,IAAI,CAAC,aAAa,EAAE;QAClB,OAAO;KACR;IACD,WAAW,CAAC,eAAe,CAAC,GAAG,CAAC,CAAC;IACjC,WAAW,CAAC,SAAS,CAAC;QACpB,IAAI,EAAE,GAAG,CAAC,cAAc,CAAC,KAAK;QAC9B,OAAO,EAAE,GAAG,CAAC,OAAO;KACrB,CAAC,CAAC;IACH,WAAW,CAAC,GAAG,EAAE,CAAC;AACpB,CAAC,CAAC;AAEF,MAAM,wBAAwB,GAAG,CAC/B,WAAqB,EACrB,aAAsB,EACtB,EAAE;IACF,IAAI,CAAC,aAAa,EAAE;QAClB,OAAO;KACR;IACD,WAAW,CAAC,GAAG,EAAE,CAAC;AACpB,CAAC,CAAC;AAEF,SAAgB,iBAAiB,CAC/B,MAAkB,EAClB,SAAoE,EACpE,aAEC,EACD,iBAAiB,GAAG,KAAK;IAEzB,IACG,oBAAoC,CAAC,6BAAmB,CAAC;QAC1D,OAAO,aAAa,KAAK,UAAU,EACnC;QACA,OAAO,aAAc,CAAC;KACvB;IAED,SAAS,oBAAoB,CAE3B,MAAe,EACf,IAAW,EACX,YAA8C,EAC9C,IAAqC;QAErC,IAAI,CAAC,aAAa,EAAE;YAClB,OAAO,SAAS,CAAC;SAClB;QACD,MAAM,MAAM,GAAG,SAAS,EAAE,CAAC;QAE3B,wEAAwE;QACxE,mDAAmD;QACnD,IACE,MAAM,CAAC,yBAAyB;YAChC,iBAAiB;YACjB,CAAC,YAAY,CAAC,MAAM,CAAC,IAAI,OAAO,MAAM,KAAK,UAAU,CAAC,EACtD;YACA,MAAM,QAAQ,GAAI,MAAc,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC;YACjD,8DAA8D;YAC9D,6FAA6F;YAC7F,IAAI,OAAO,QAAQ,KAAK,UAAU,EAAE;gBAClC,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;aACnE;SACF;QAED,IAAI,CAAC,YAAY,CAAC,kCAAwB,CAAC,EAAE;YAC3C,OAAO,aAAa,CAAC,IAAI,CAAC,IAAI,EAAE,MAAM,EAAE,IAAI,EAAE,YAAY,EAAE,IAAI,CAAC,CAAC;SACnE;QACD,MAAM,IAAI,GAAG,WAAW,CAAC,MAAM,CAAC,UAAU,EAAE,IAAI,IAAI,IAAI,CAAC,IAAI,CAAC,CAAC;QAC/D,MAAM,KAAK,GAAG,IAAI,CAAC,MAAM,CAAC,CAAC,IAAS,EAAE,EAAE,CAAC,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,MAAM,CAAC;QAE1E,IAAI,KAAU,CAAC;QACf,IAAI,aAAa,GAAG,KAAK,CAAC;QAC1B,IAAI,MAAM,CAAC,KAAK,IAAI,CAAC,IAAI,MAAM,CAAC,KAAK,GAAG,KAAK,EAAE;YAC7C,KAAK,GAAG,cAAc,CAAC,YAAY,EAAE,IAAI,CAAC,CAAC;SAC5C;aAAM;YACL,MAAM,QAAQ,GAAG,sBAAsB,CACrC,MAAM,EACN,SAAS,EACT,YAAY,EACZ,IAAI,EACJ,IAAI,CACL,CAAC;YACF,KAAK,GAAG,QAAQ,CAAC,KAAK,CAAC;YACvB,aAAa,GAAG,QAAQ,CAAC,SAAS,CAAC;SACpC;QAED,OAAO,GAAG,CAAC,OAAO,CAAC,IAAI,CACrB,GAAG,CAAC,KAAK,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,MAAM,EAAE,EAAE,KAAK,CAAC,IAAI,CAAC,EACnD,GAAG,EAAE;YACH,IAAI;gBACF,MAAM,GAAG,GAAG,aAAa,CAAC,IAAI,CAC5B,IAAI,EACJ,MAAM,EACN,IAAI,EACJ,YAAY,EACZ,IAAI,CACL,CAAC;gBACF,IAAI,IAAA,iBAAS,EAAC,GAAG,CAAC,EAAE;oBAClB,OAAO,GAAG,CAAC,IAAI,CACb,CAAC,CAAM,EAAE,EAAE;wBACT,wBAAwB,CAAC,KAAK,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;wBACpD,OAAO,CAAC,CAAC;oBACX,CAAC,EACD,CAAC,GAAU,EAAE,EAAE;wBACb,sBAAsB,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;wBACvD,MAAM,GAAG,CAAC;oBACZ,CAAC,CACF,CAAC;iBACH;qBAAM;oBACL,wBAAwB,CAAC,KAAK,CAAC,IAAI,EAAE,aAAa,CAAC,CAAC;oBACpD,OAAO,GAAG,CAAC;iBACZ;aACF;YAAC,OAAO,GAAQ,EAAE;gBACjB,sBAAsB,CAAC,KAAK,CAAC,IAAI,EAAE,GAAG,EAAE,aAAa,CAAC,CAAC;gBACvD,MAAM,GAAG,CAAC;aACX;QACH,CAAC,CACF,CAAC;IACJ,CAAC;IAEA,oBAAoC,CAAC,6BAAmB,CAAC,GAAG,IAAI,CAAC;IAElE,OAAO,oBAAoB,CAAC;AAC9B,CAAC;AArGD,8CAqGC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport type * as graphqlTypes from 'graphql';\nimport * as api from '@opentelemetry/api';\nimport {  SpanNames } from './enum';\nimport { AttributeNames } from './enums/AttributeNames';\nimport { OTEL_GRAPHQL_DATA_SYMBOL, OTEL_PATCHED_SYMBOL } from './symbols';\nimport {\n  GraphQLField,\n  GraphQLPath,\n  GraphQLInstrumentationParsedConfig,\n  ObjectWithGraphQLData,\n  OtelPatched,\n  Maybe,\n} from './internal-types';\nimport { GraphQLToolsExecutorInstrumentationConfig } from './types';\nexport {\n  isPromise,\n  addInputVariableAttributes,\n  addSpanSource,\n  endSpan,\n  getOperation,\n  wrapFields,\n} from '@opentelemetry/instrumentation-graphql/build/src/utils';\n\nimport {\n  isPromise,\n  addSpanSource,\n} from '@opentelemetry/instrumentation-graphql/build/src/utils';\n\n\n// https://github.com/graphql/graphql-js/blob/main/src/jsutils/isObjectLike.ts\nconst isObjectLike = (value: unknown): value is { [key: string]: unknown } => {\n  return typeof value == 'object' && value !== null;\n};\n\nfunction createFieldIfNotExists(\n  tracer: api.Tracer,\n  getConfig: () => GraphQLInstrumentationParsedConfig,\n  contextValue: any,\n  info: graphqlTypes.GraphQLResolveInfo,\n  path: string[]\n): {\n  field: any;\n  spanAdded: boolean;\n} {\n  let field = getField(contextValue, path);\n\n  let spanAdded = false;\n\n  if (!field) {\n    spanAdded = true;\n    const parent = getParentField(contextValue, path);\n\n    field = {\n      parent,\n      span: createResolverSpan(\n        tracer,\n        getConfig,\n        contextValue,\n        info,\n        path,\n        parent.span\n      ),\n      error: null,\n    };\n\n    addField(contextValue, path, field);\n  }\n\n  return { spanAdded, field };\n}\n\nfunction createResolverSpan(\n  tracer: api.Tracer,\n  getConfig: () => GraphQLInstrumentationParsedConfig,\n  contextValue: any,\n  info: graphqlTypes.GraphQLResolveInfo,\n  path: string[],\n  parentSpan?: api.Span\n): api.Span {\n  const attributes: api.SpanAttributes = {\n    [AttributeNames.FIELD_NAME]: info.fieldName,\n    [AttributeNames.FIELD_PATH]: path.join('.'),\n    [AttributeNames.FIELD_TYPE]: info.returnType.toString(),\n  };\n\n  const span = tracer.startSpan(\n    SpanNames.RESOLVE,\n    {\n      attributes,\n    },\n    parentSpan ? api.trace.setSpan(api.context.active(), parentSpan) : undefined\n  );\n\n  const document = contextValue[OTEL_GRAPHQL_DATA_SYMBOL].source;\n  const fieldNode = info.fieldNodes.find(\n    fieldNode => fieldNode.kind === 'Field'\n  );\n\n  if (fieldNode) {\n    addSpanSource(\n      span,\n      document.loc,\n      getConfig().allowValues,\n      fieldNode.loc?.start,\n      fieldNode.loc?.end\n    );\n  }\n\n  return span;\n}\n\n\nfunction addField(contextValue: any, path: string[], field: GraphQLField) {\n  return (contextValue[OTEL_GRAPHQL_DATA_SYMBOL].fields[path.join('.')] =\n    field);\n}\n\nfunction getField(contextValue: any, path: string[]) {\n  return contextValue[OTEL_GRAPHQL_DATA_SYMBOL].fields[path.join('.')];\n}\n\nfunction getParentField(contextValue: any, path: string[]) {\n  for (let i = path.length - 1; i > 0; i--) {\n    const field = getField(contextValue, path.slice(0, i));\n\n    if (field) {\n      return field;\n    }\n  }\n\n  return {\n    span: contextValue[OTEL_GRAPHQL_DATA_SYMBOL].span,\n  };\n}\n\nfunction pathToArray(mergeItems: boolean, path: GraphQLPath): string[] {\n  const flattened: string[] = [];\n  let curr: GraphQLPath | undefined = path;\n  while (curr) {\n    let key = curr.key;\n\n    if (mergeItems && typeof key === 'number') {\n      key = '*';\n    }\n    flattened.push(String(key));\n    curr = curr.prev;\n  }\n  return flattened.reverse();\n}\n\n\n\n\n\n\nconst handleResolveSpanError = (\n  resolveSpan: api.Span,\n  err: any,\n  shouldEndSpan: boolean\n) => {\n  if (!shouldEndSpan) {\n    return;\n  }\n  resolveSpan.recordException(err);\n  resolveSpan.setStatus({\n    code: api.SpanStatusCode.ERROR,\n    message: err.message,\n  });\n  resolveSpan.end();\n};\n\nconst handleResolveSpanSuccess = (\n  resolveSpan: api.Span,\n  shouldEndSpan: boolean\n) => {\n  if (!shouldEndSpan) {\n    return;\n  }\n  resolveSpan.end();\n};\n\nexport function wrapFieldResolver<TSource = any, TContext = any, TArgs = any>(\n  tracer: api.Tracer,\n  getConfig: () => Required<GraphQLToolsExecutorInstrumentationConfig>,\n  fieldResolver: Maybe<\n    graphqlTypes.GraphQLFieldResolver<TSource, TContext, TArgs> & OtelPatched\n  >,\n  isDefaultResolver = false\n): graphqlTypes.GraphQLFieldResolver<TSource, TContext, TArgs> & OtelPatched {\n  if (\n    (wrappedFieldResolver as OtelPatched)[OTEL_PATCHED_SYMBOL] ||\n    typeof fieldResolver !== 'function'\n  ) {\n    return fieldResolver!;\n  }\n\n  function wrappedFieldResolver(\n    this: graphqlTypes.GraphQLFieldResolver<TSource, TContext, TArgs>,\n    source: TSource,\n    args: TArgs,\n    contextValue: TContext & ObjectWithGraphQLData,\n    info: graphqlTypes.GraphQLResolveInfo\n  ) {\n    if (!fieldResolver) {\n      return undefined;\n    }\n    const config = getConfig();\n\n    // follows what graphql is doing to decied if this is a trivial resolver\n    // for which we don't need to create a resolve span\n    if (\n      config.ignoreTrivialResolveSpans &&\n      isDefaultResolver &&\n      (isObjectLike(source) || typeof source === 'function')\n    ) {\n      const property = (source as any)[info.fieldName];\n      // a function execution is not trivial and should be recorder.\n      // property which is not a function is just a value and we don't want a \"resolve\" span for it\n      if (typeof property !== 'function') {\n        return fieldResolver.call(this, source, args, contextValue, info);\n      }\n    }\n\n    if (!contextValue[OTEL_GRAPHQL_DATA_SYMBOL]) {\n      return fieldResolver.call(this, source, args, contextValue, info);\n    }\n    const path = pathToArray(config.mergeItems, info && info.path);\n    const depth = path.filter((item: any) => typeof item === 'string').length;\n\n    let field: any;\n    let shouldEndSpan = false;\n    if (config.depth >= 0 && config.depth < depth) {\n      field = getParentField(contextValue, path);\n    } else {\n      const newField = createFieldIfNotExists(\n        tracer,\n        getConfig,\n        contextValue,\n        info,\n        path\n      );\n      field = newField.field;\n      shouldEndSpan = newField.spanAdded;\n    }\n\n    return api.context.with(\n      api.trace.setSpan(api.context.active(), field.span),\n      () => {\n        try {\n          const res = fieldResolver.call(\n            this,\n            source,\n            args,\n            contextValue,\n            info\n          );\n          if (isPromise(res)) {\n            return res.then(\n              (r: any) => {\n                handleResolveSpanSuccess(field.span, shouldEndSpan);\n                return r;\n              },\n              (err: Error) => {\n                handleResolveSpanError(field.span, err, shouldEndSpan);\n                throw err;\n              }\n            );\n          } else {\n            handleResolveSpanSuccess(field.span, shouldEndSpan);\n            return res;\n          }\n        } catch (err: any) {\n          handleResolveSpanError(field.span, err, shouldEndSpan);\n          throw err;\n        }\n      }\n    );\n  }\n\n  (wrappedFieldResolver as OtelPatched)[OTEL_PATCHED_SYMBOL] = true;\n\n  return wrappedFieldResolver;\n}\n"]}